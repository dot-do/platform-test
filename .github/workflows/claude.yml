name: Claude Code

run-name: "Claude Code - #${{ github.event.issue.number || github.event.pull_request.number || 'unknown' }}"

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request:
    types: [assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    # Only trigger on @claude mentions (not other bot mentions)
    if: |
      (github.event_name == 'issue_comment' &&
       github.event.comment.user.type != 'Bot' &&
       !contains(github.event.comment.body, '@claude please review') &&
       !contains(github.event.comment.body, '@claude review') &&
       !contains(github.event.comment.body, 'trigger review') &&
       contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' &&
       github.event.comment.user.type != 'Bot' &&
       !contains(github.event.comment.body, '@claude please review') &&
       !contains(github.event.comment.body, '@claude review') &&
       !contains(github.event.comment.body, 'trigger review') &&
       contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && github.event.action == 'submitted' && github.event.review.state == 'CHANGES_REQUESTED') ||
      (github.event_name == 'issues' && github.event.action == 'assigned') ||
      (github.event_name == 'pull_request' && github.event.action == 'assigned') ||
      (github.event_name == 'issues' && (
        contains(github.event.issue.body, '@claude') ||
        contains(github.event.issue.title, '@claude')
      ))
    runs-on: blacksmith-4vcpu-ubuntu-2404
    concurrency:
      group: claude-${{ github.event.issue.number || github.event.pull_request.number }}
      cancel-in-progress: true
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Get issue/PR info
        id: issue_pr_info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get issue or PR number from various event types
          if [ "${{ github.event_name }}" = "issues" ]; then
            NUMBER="${{ github.event.issue.number }}"
            IS_PR="false"
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            NUMBER="${{ github.event.issue.number }}"
            # Check if this is a PR comment (issue.pull_request will be set)
            if [ -n "${{ github.event.issue.pull_request }}" ]; then
              IS_PR="true"
            else
              IS_PR="false"
            fi
          else
            NUMBER="${{ github.event.pull_request.number }}"
            IS_PR="true"
          fi

          echo "number=$NUMBER" >> $GITHUB_OUTPUT
          echo "is_pr=$IS_PR" >> $GITHUB_OUTPUT

          # Check for existing bot reviewer (only for PRs)
          # This ensures the same reviewer handles all reviews on a PR
          EXISTING_REVIEWER=""

          if [ "$IS_PR" = "true" ] && [ -n "$NUMBER" ]; then
            echo "Checking for existing reviewer on PR #$NUMBER..."
            REVIEWS_DATA=$(gh pr view $NUMBER --repo ${{ github.repository }} --json reviews --jq '.reviews[].author.login' 2>/dev/null || echo "")

            if [ -n "$REVIEWS_DATA" ]; then
              # Look for the first bot account that reviewed (in chronological order)
              while IFS= read -r reviewer; do
                # Check if reviewer matches any bot account pattern
                case "$reviewer" in
                  nathanclevenger|tom*|Tom*|amy*|Amy*|cody*|Cody*|priya*|Priya*|quinn*|Quinn*)
                    EXISTING_REVIEWER="$reviewer"
                    echo "üîí Found existing bot reviewer: $EXISTING_REVIEWER"
                    break
                    ;;
                esac
              done <<< "$REVIEWS_DATA"
            fi
          fi

          echo "existing_reviewer=$EXISTING_REVIEWER" >> $GITHUB_OUTPUT

      - name: Detect mentioned agent
        id: detect_agent
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          COMMENT_BODY_RAW: ${{ github.event.comment.body }}
        run: |
          # Check which agent was mentioned in comments or issue body/title
          MENTIONED_AGENT=""
          COMMENT_BODY=""

          if [ "${{ github.event_name }}" = "issue_comment" ] || [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            COMMENT_BODY="$COMMENT_BODY_RAW"
          elif [ "${{ github.event_name }}" = "issues" ]; then
            COMMENT_BODY="$ISSUE_BODY $ISSUE_TITLE"
          fi

          # Priority: specific agent mentions override @claude
          if echo "$COMMENT_BODY" | grep -q "@amy-doyle"; then
            MENTIONED_AGENT="amy-doyle"
          elif echo "$COMMENT_BODY" | grep -q "@tomdolen"; then
            MENTIONED_AGENT="tomdolen"
          elif echo "$COMMENT_BODY" | grep -q "@cody-do-code"; then
            MENTIONED_AGENT="cody-do-code"
          elif echo "$COMMENT_BODY" | grep -q "@priya-pdm"; then
            MENTIONED_AGENT="priya-pdm"
          elif echo "$COMMENT_BODY" | grep -q "@claude"; then
            MENTIONED_AGENT="claude"
          fi

          echo "mentioned_agent=$MENTIONED_AGENT" >> $GITHUB_OUTPUT

          if [ -n "$MENTIONED_AGENT" ]; then
            echo "üéØ Detected mentioned agent: @$MENTIONED_AGENT"
          else
            echo "‚ÑπÔ∏è  No agent mention detected (using assignee/random selection)"
          fi

      - name: Select GitHub PAT (by mentioned agent, existing reviewer, assignee, or random)
        id: select_pat
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          GH_PAT: ${{ secrets.GH_PAT }}
          AMY_GH_PAT: ${{ secrets.AMY_GH_PAT }}
          TOM_GH_PAT: ${{ secrets.TOM_GH_PAT }}
          CODY_GH_PAT: ${{ secrets.CODY_GH_PAT }}
          PRIYA_GH_PAT: ${{ secrets.PRIYA_GH_PAT }}
          QUINN_GH_PAT: ${{ secrets.QUINN_GH_PAT }}
        run: |
          # CRITICAL SECURITY: Mask all PATs IMMEDIATELY before any operations
          # This prevents exposure if the script fails before masking the selected PAT
          [ -n "$GH_PAT" ] && echo "::add-mask::${GH_PAT}"
          [ -n "$AMY_GH_PAT" ] && echo "::add-mask::${AMY_GH_PAT}"
          [ -n "$TOM_GH_PAT" ] && echo "::add-mask::${TOM_GH_PAT}"
          [ -n "$CODY_GH_PAT" ] && echo "::add-mask::${CODY_GH_PAT}"
          [ -n "$PRIYA_GH_PAT" ] && echo "::add-mask::${PRIYA_GH_PAT}"
          [ -n "$QUINN_GH_PAT" ] && echo "::add-mask::${QUINN_GH_PAT}"

          # Priority 1: Check for specific agent mention (highest priority)
          MENTIONED_AGENT="${{ steps.detect_agent.outputs.mentioned_agent }}"

          if [ -n "$MENTIONED_AGENT" ] && [ "$MENTIONED_AGENT" != "claude" ]; then
            echo "üéØ Agent mentioned: @$MENTIONED_AGENT"

            case "$MENTIONED_AGENT" in
              amy-doyle)
                SELECTED_PAT="$AMY_GH_PAT"
                SELECTED_NAME="AMY_GH_PAT"
                SELECTED_USERNAME="amy-doyle"
                ;;
              tomdolen)
                SELECTED_PAT="$TOM_GH_PAT"
                SELECTED_NAME="TOM_GH_PAT"
                SELECTED_USERNAME="tomdolen"
                ;;
              cody-do-code)
                SELECTED_PAT="$CODY_GH_PAT"
                SELECTED_NAME="CODY_GH_PAT"
                SELECTED_USERNAME="cody-do-code"
                ;;
              priya-pdm)
                SELECTED_PAT="$PRIYA_GH_PAT"
                SELECTED_NAME="PRIYA_GH_PAT"
                SELECTED_USERNAME="priya-pdm"
                ;;
            esac

            if [ -n "$SELECTED_PAT" ]; then
              echo "selected_pat=${SELECTED_PAT}" >> $GITHUB_OUTPUT
              echo "selected_username=${SELECTED_USERNAME}" >> $GITHUB_OUTPUT
              echo "‚úÖ Using $SELECTED_NAME for @$MENTIONED_AGENT mention"
              exit 0
            fi
          fi

          # Priority 2: Check for existing bot reviewer (sticky reviewer for consistency)
          # This ensures the same reviewer handles all work on a PR
          EXISTING_REVIEWER="${{ steps.issue_pr_info.outputs.existing_reviewer }}"

          if [ -n "$EXISTING_REVIEWER" ]; then
            echo "üîí Sticky reviewer detected: $EXISTING_REVIEWER"

            # Map existing reviewer to their PAT (supports multiple username patterns)
            case "$EXISTING_REVIEWER" in
              nathanclevenger)
                SELECTED_PAT="$GH_PAT"
                SELECTED_NAME="GH_PAT (Nathan)"
                ;;
              tom*|Tom*)
                SELECTED_PAT="$TOM_GH_PAT"
                SELECTED_NAME="TOM_GH_PAT"
                ;;
              amy*|Amy*)
                SELECTED_PAT="$AMY_GH_PAT"
                SELECTED_NAME="AMY_GH_PAT"
                ;;
              cody*|Cody*)
                SELECTED_PAT="$CODY_GH_PAT"
                SELECTED_NAME="CODY_GH_PAT"
                ;;
              priya*|Priya*)
                SELECTED_PAT="$PRIYA_GH_PAT"
                SELECTED_NAME="PRIYA_GH_PAT"
                ;;
              quinn*|Quinn*)
                SELECTED_PAT="$QUINN_GH_PAT"
                SELECTED_NAME="QUINN_GH_PAT"
                ;;
              *)
                echo "‚ö†Ô∏è  Unknown existing reviewer: $EXISTING_REVIEWER, falling back to random selection"
                SELECTED_PAT=""
                ;;
            esac

            if [ -n "$SELECTED_PAT" ]; then
              echo "selected_pat=${SELECTED_PAT}" >> $GITHUB_OUTPUT
              echo "selected_username=${EXISTING_REVIEWER}" >> $GITHUB_OUTPUT
              echo "‚úÖ Using sticky reviewer's PAT: $SELECTED_NAME (maintains consistency)"
              exit 0
            fi
          fi

          # Check if this is an assignment event and map to specific PAT
          ASSIGNEE="${{ github.event.assignee.login }}"

          if [ -n "$ASSIGNEE" ]; then
            echo "üéØ Assignment detected: $ASSIGNEE"

            # Map assignee to PAT (supports multiple username patterns)
            case "$ASSIGNEE" in
              nathanclevenger)
                SELECTED_PAT="$GH_PAT"
                SELECTED_NAME="GH_PAT (Nathan)"
                ;;
              tom*|Tom*)
                SELECTED_PAT="$TOM_GH_PAT"
                SELECTED_NAME="TOM_GH_PAT"
                ;;
              amy*|Amy*)
                SELECTED_PAT="$AMY_GH_PAT"
                SELECTED_NAME="AMY_GH_PAT"
                ;;
              cody*|Cody*)
                SELECTED_PAT="$CODY_GH_PAT"
                SELECTED_NAME="CODY_GH_PAT"
                ;;
              priya*|Priya*)
                SELECTED_PAT="$PRIYA_GH_PAT"
                SELECTED_NAME="PRIYA_GH_PAT"
                ;;
              quinn*|Quinn*)
                SELECTED_PAT="$QUINN_GH_PAT"
                SELECTED_NAME="QUINN_GH_PAT"
                ;;
              *)
                echo "‚ö†Ô∏è  Unknown assignee: $ASSIGNEE, falling back to random selection"
                SELECTED_PAT=""
                ;;
            esac

            if [ -n "$SELECTED_PAT" ]; then
              echo "selected_pat=${SELECTED_PAT}" >> $GITHUB_OUTPUT
              echo "selected_username=${ASSIGNEE}" >> $GITHUB_OUTPUT
              echo "‚úÖ Selected $SELECTED_NAME for assignee $ASSIGNEE"
              exit 0
            fi
          fi

          # No assignee or unknown assignee - use random PAT selection
          echo "üé≤ Using random PAT selection for @claude mention"

          # Array of available PATs (now safe to work with - all are masked)
          PATS=()
          PAT_NAMES=()

          # Add available PATs to array (only if they exist)
          if [ -n "$GH_PAT" ]; then
            PATS+=("$GH_PAT")
            PAT_NAMES+=("GH_PAT")
          fi
          if [ -n "$AMY_GH_PAT" ]; then
            PATS+=("$AMY_GH_PAT")
            PAT_NAMES+=("AMY_GH_PAT")
          fi
          if [ -n "$TOM_GH_PAT" ]; then
            PATS+=("$TOM_GH_PAT")
            PAT_NAMES+=("TOM_GH_PAT")
          fi
          if [ -n "$CODY_GH_PAT" ]; then
            PATS+=("$CODY_GH_PAT")
            PAT_NAMES+=("CODY_GH_PAT")
          fi
          if [ -n "$PRIYA_GH_PAT" ]; then
            PATS+=("$PRIYA_GH_PAT")
            PAT_NAMES+=("PRIYA_GH_PAT")
          fi
          # NOTE: Quinn is excluded from random selection - Quinn is only used for code reviews in claude-review.yml
          # if [ -n "$QUINN_GH_PAT" ]; then
          #   PATS+=("$QUINN_GH_PAT")
          #   PAT_NAMES+=("QUINN_GH_PAT")
          # fi

          # Ensure we have at least one PAT
          if [ ${#PATS[@]} -eq 0 ]; then
            echo "‚ùå No GitHub PATs available"
            exit 1
          fi

          # Randomly select a PAT (already masked above)
          # Note: Uses bash $RANDOM for simple load balancing (not cryptographic security)
          # This is sufficient for distributing PAT usage across multiple tokens
          RANDOM_INDEX=$((RANDOM % ${#PATS[@]}))
          SELECTED_PAT="${PATS[$RANDOM_INDEX]}"
          SELECTED_NAME="${PAT_NAMES[$RANDOM_INDEX]}"

          # Get username for the selected PAT
          # Use a subshell with the selected PAT to avoid exposing it
          SELECTED_USERNAME=$(GH_TOKEN="${SELECTED_PAT}" gh api user --jq '.login' 2>/dev/null || echo "")

          if [ -z "$SELECTED_USERNAME" ]; then
            echo "‚ö†Ô∏è  Failed to get username for selected PAT, falling back to generic name"
            SELECTED_USERNAME="claude-bot"
          fi

          # Output the selected PAT and username (already masked in logs)
          echo "selected_pat=${SELECTED_PAT}" >> $GITHUB_OUTPUT
          echo "selected_username=${SELECTED_USERNAME}" >> $GITHUB_OUTPUT
          echo "‚úÖ Selected ${SELECTED_NAME} (${#PATS[@]} PATs available) - username: ${SELECTED_USERNAME}"

      - name: Post progress comment
        id: progress_comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_pat.outputs.selected_pat }}
          script: |
            const issueNumber = context.issue.number || context.payload.pull_request.number;
            const isPR = context.payload.issue?.pull_request || context.payload.pull_request;
            const type = isPR ? 'PR' : 'issue';

            const comment = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `## üîµ Working on this ${type}

            **Status**: Starting work
            **Agent**: ${{ steps.select_pat.outputs.selected_username }}
            **Workflow**: [Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            ---
            *This comment will be updated when work is complete*`
            });

            return comment.data.id;

      - name: Add emoji reaction
        if: github.event_name == 'issue_comment' || github.event_name == 'pull_request_review_comment'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_pat.outputs.selected_pat }}
          script: |
            const commentId = context.payload.comment.id;
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              content: 'eyes'
            });

      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          token: ${{ steps.select_pat.outputs.selected_pat }}
          fetch-depth: 0 # Full history for proper branching

      - name: Configure Git
        run: |
          git config --global user.name "Claude Code"
          git config --global user.email "claude-code[bot]@users.noreply.github.com"

      - name: Create Neon Database Branch
        id: neon-branch
        continue-on-error: true  # Graceful degradation: continues without DB if Neon unavailable
        uses: neondatabase/create-branch-action@v6.1.1
        timeout-minutes: 5  # Typical: <30s, allows time for retries
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          # Ephemeral branch: claude/issue-{number}-{run_id}
          branch_name: claude/issue-${{ github.event.issue.number || github.event.pull_request.number }}-${{ github.run_id }}
          database: ${{ vars.NEON_DATABASE_NAME || 'do' }}
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Mask database URLs
        if: steps.neon-branch.outcome == 'success'
        run: |
          # CRITICAL SECURITY: Mask credentials immediately after creation, before any other steps
          # Prevent database URLs and branch ID from appearing in workflow logs
          echo "::add-mask::${{ steps.neon-branch.outputs.db_url_pooled }}"
          echo "::add-mask::${{ steps.neon-branch.outputs.db_url }}"
          echo "::add-mask::${{ steps.neon-branch.outputs.branch_id }}"

      - name: Reset workflow labels
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
          # Remove any existing workflow state labels and add todo label in a single API call
          # Note: Using '2>/dev/null || true' pattern intentionally here because labels may not exist
          gh issue edit "$ISSUE_NUM" \
            --remove-label "üü° todo" \
            --remove-label "üîµ in-progress" \
            --remove-label "üü† in-review" \
            --remove-label "üü£ in-review" \
            --remove-label "üîß changes-requested" \
            --remove-label "üü¢ approved" \
            --remove-label "‚úÖ done" \
            --remove-label "‚ùå failed" \
            --add-label "üü° todo" \
            2>/dev/null || true

      - name: Create working branch
        id: branch
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Check if this is being triggered on an existing PR
          if [ "${{ github.event_name }}" = "pull_request_review" ] || [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            # This is a PR event - reuse the existing PR branch
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BRANCH_NAME=$(gh pr view $PR_NUMBER --json headRefName -q '.headRefName')

            echo "üîÑ Reusing existing PR branch: $BRANCH_NAME"

            # Fetch and checkout the PR branch
            git fetch origin "$BRANCH_NAME"
            git checkout "$BRANCH_NAME"
            git pull origin "$BRANCH_NAME"

          elif [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.action }}" = "assigned" ]; then
            # PR assignment - reuse existing PR branch
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BRANCH_NAME=$(gh pr view $PR_NUMBER --json headRefName -q '.headRefName')

            echo "üîÑ Reusing existing PR branch: $BRANCH_NAME"

            # Fetch and checkout the PR branch
            git fetch origin "$BRANCH_NAME"
            git checkout "$BRANCH_NAME"
            git pull origin "$BRANCH_NAME"

          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            # Could be a comment on an issue OR a PR - check which
            IS_PR="${{ github.event.issue.pull_request != null }}"

            if [ "$IS_PR" = "true" ]; then
              # Comment on a PR - reuse existing branch
              PR_NUMBER="${{ github.event.issue.number }}"
              BRANCH_NAME=$(gh pr view $PR_NUMBER --json headRefName -q '.headRefName')

              echo "üîÑ Reusing existing PR branch: $BRANCH_NAME"

              # Fetch and checkout the PR branch
              git fetch origin "$BRANCH_NAME"
              git checkout "$BRANCH_NAME"
              git pull origin "$BRANCH_NAME"
            else
              # Comment on an issue - create new branch from main
              git fetch origin main
              git checkout main
              git pull origin main

              ISSUE_NUM="${{ github.event.issue.number }}"
              # Use run_id for guaranteed uniqueness (prevents race conditions when multiple workflows trigger)
              BRANCH_NAME="claude/issue-${ISSUE_NUM}-${{ github.run_id }}"

              echo "‚ú® Creating new branch: $BRANCH_NAME"

              # Delete local/remote branch if it exists
              # Note: Using '2>/dev/null || true' intentionally - branch may not exist
              git branch -D "$BRANCH_NAME" 2>/dev/null || true
              git push origin --delete "$BRANCH_NAME" 2>/dev/null || true

              git checkout -b "$BRANCH_NAME"
            fi
          else
            # New issue opened/assigned - create new branch from main
            git fetch origin main
            git checkout main
            git pull origin main

            ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
            # Use run_id for guaranteed uniqueness (prevents race conditions when multiple workflows trigger)
            BRANCH_NAME="claude/issue-${ISSUE_NUM}-${{ github.run_id }}"

            echo "‚ú® Creating new branch: $BRANCH_NAME"

            # Delete local/remote branch if it exists
            # Note: Using '2>/dev/null || true' intentionally - branch may not exist
            git branch -D "$BRANCH_NAME" 2>/dev/null || true
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || true

            git checkout -b "$BRANCH_NAME"
          fi

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Update to in-progress label
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
          # Remove todo label and add in-progress label in a single API call
          # Note: Using '2>/dev/null || true' intentionally - label may not exist
          gh issue edit "$ISSUE_NUM" \
            --remove-label "üü° todo" \
            --add-label "üîµ in-progress" \
            2>/dev/null || true

      - name: Validate Neon Branch Creation
        if: always()
        timeout-minutes: 2
        run: |
          # Handle all possible step outcomes explicitly
          if [ "${{ steps.neon-branch.outcome }}" = "skipped" ]; then
            echo "‚è≠Ô∏è  Neon branch creation was skipped - Claude will run without database access"
            exit 0
          elif [ "${{ steps.neon-branch.outcome }}" = "success" ]; then
            # Verify outputs are present
            if [ -z "${{ steps.neon-branch.outputs.db_url_pooled }}" ]; then
              echo "‚ùå Neon branch was created but database URL is empty"
              exit 1
            fi
            echo "‚úÖ Neon branch created successfully"
            exit 0
          elif [ "${{ steps.neon-branch.outcome }}" = "failure" ]; then
            echo "‚ö†Ô∏è  Neon branch creation failed - Claude will run without database access"
            echo "Reason: Timeout, API error, or rate limiting"
            echo "This is expected behavior with continue-on-error: true"
            exit 0
          elif [ "${{ steps.neon-branch.outcome }}" = "cancelled" ]; then
            echo "‚è≠Ô∏è  Neon branch creation cancelled - continuing without DB"
            exit 0
          else
            echo "‚ùå Unexpected outcome: ${{ steps.neon-branch.outcome }}"
            exit 1
          fi

      - name: Prepare Claude Code settings
        id: claude_settings
        run: |
          # Conditionally include database settings only if Neon branch was created successfully
          # Check both outcome and skip status to handle all cases
          if [ "${{ steps.neon-branch.outcome }}" = "skipped" ]; then
            echo "‚è≠Ô∏è  Neon branch was skipped - Claude Code will run without database access"
            SETTINGS="{}"
          elif [ "${{ steps.neon-branch.outcome }}" = "success" ] && [ -n "${{ steps.neon-branch.outputs.db_url_pooled }}" ]; then
            echo "‚úÖ Including database credentials in Claude Code settings"

            # Validate URL format before constructing JSON
            if [[ ! "${{ steps.neon-branch.outputs.db_url_pooled }}" =~ ^postgres:// ]]; then
              echo "‚ùå Invalid database URL format (expected postgres://)"
              SETTINGS="{}"
            else
              # Use jq to safely construct JSON, properly escaping special characters
              if ! SETTINGS=$(jq -n \
                --arg db_url "${{ steps.neon-branch.outputs.db_url_pooled }}" \
                --arg direct_url "${{ steps.neon-branch.outputs.db_url }}" \
                '{env: {DATABASE_URL: $db_url, DIRECT_DATABASE_URL: $direct_url}}'); then
                echo "‚ùå Failed to construct settings JSON"
                SETTINGS="{}"
              fi
            fi
          else
            echo "‚ö†Ô∏è Neon branch not available - Claude Code will run without database access"
            SETTINGS="{}"
          fi

          # CRITICAL: Ensure SETTINGS is always set, even if jq failed silently
          # This prevents passing undefined/malformed JSON to Claude Code action
          SETTINGS="${SETTINGS:-"{}"}"

          # Set output (using heredoc to handle multiline)
          echo "settings<<EOF" >> $GITHUB_OUTPUT
          echo "$SETTINGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate prompt for assignment triggers
        id: generate_prompt
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'assigned') ||
          (github.event_name == 'issues' && github.event.action == 'assigned')
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          set -e

          # Handle both PR and issue assignments
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            ITEM_TYPE="PR"
            ITEM_NUMBER="${{ github.event.pull_request.number }}"
            echo "üéØ Generating prompt for PR assignment (PR #$ITEM_NUMBER)"

            # Get PR description
            ITEM_BODY=$(gh pr view "$ITEM_NUMBER" --json body --jq '.body // ""')

            # Generate contextual prompt from PR description
            if [ -n "$ITEM_BODY" ] && [ "$ITEM_BODY" != "null" ]; then
              PROMPT="Please review this PR and address any issues described in the PR description:

          $ITEM_BODY

          Focus on:
          1. Reviewing the code changes
          2. Addressing any issues or feedback mentioned
          3. Ensuring tests pass
          4. Following the project's code standards

          The workflow will automatically commit and push your changes."
            else
              PROMPT="Please review this PR, address any issues, and ensure all tests pass. The workflow will automatically commit and push your changes."
            fi
          else
            ITEM_TYPE="issue"
            ITEM_NUMBER="${{ github.event.issue.number }}"
            echo "üéØ Generating prompt for issue assignment (issue #$ITEM_NUMBER)"

            # Get issue description
            ITEM_BODY=$(gh issue view "$ITEM_NUMBER" --json body --jq '.body // ""')

            # Generate contextual prompt from issue description
            if [ -n "$ITEM_BODY" ] && [ "$ITEM_BODY" != "null" ]; then
              PROMPT="Please address the issue described below:

          $ITEM_BODY

          Focus on:
          1. Understanding the problem or feature request
          2. Implementing the necessary changes
          3. Ensuring tests pass
          4. Following the project's code standards

          The workflow will automatically create a PR with your changes."
            else
              PROMPT="Please address this issue and create a PR with the necessary changes. Ensure all tests pass."
            fi
          fi

          # Set output (using heredoc for multiline)
          echo "prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "‚úÖ Generated prompt from $ITEM_TYPE description"

      - name: Run Claude Code
        id: claude
        uses: dot-do/claude-code-action@fix/support-assigned-action-with-track-progress
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.select_pat.outputs.selected_pat }}

          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read

          # Optional: Give a custom prompt to Claude. If this is not specified, Claude will perform the instructions specified in the comment that tagged it.
          # For assignment triggers, use the generated prompt from PR description. For @claude comments, leave empty to use the comment.
          prompt: ${{ steps.generate_prompt.outputs.prompt || '' }}

          # Allow claude[bot] and blacksmith-sh to trigger the workflow
          # claude[bot]: automated review feedback loop
          # blacksmith-sh: CI/CD runner (Blacksmith)
          allowed_bots: 'claude[bot],blacksmith-sh'

          # Trigger Claude when issue/PR is assigned to any bot account
          # This enables the assignment-based triggering documented in CLAUDE.md
          assignee_trigger: 'nathanclevenger,tomdolen,amy-doyle,cody-do-code,priya-pdm,quinn-qa'

          # Optional: Add claude_args to customize behavior and configuration
          # See https://github.com/dot-do/claude-code-action/blob/main/docs/usage.md
          # or https://docs.claude.com/en/docs/claude-code/cli-reference for available options
          claude_args: '--allowed-tools "Read,Write,Edit,Glob,Grep,NotebookEdit,TodoWrite,Task,Bash,WebSearch,WebFetch(domain:*)"'

          # Enable real-time progress tracking with live task list updates
          track_progress: true

          # Provide Neon database access to Claude Code (conditionally)
          # Security: These credentials are for an ephemeral branch created specifically for this workflow run
          # - Scope: Limited to the temporary Neon branch (isolated from production/development databases)
          # - Lifecycle: Branch and credentials are automatically cleaned up after workflow completion
          # - Access: Read/write access only to the ephemeral branch's data
          # - Safety: Settings are only populated if Neon branch creation succeeded (prevents empty/malformed JSON)
          settings: ${{ steps.claude_settings.outputs.settings }}

      - name: Check for changes or commits
        id: changes
        run: |
          # Check if there are uncommitted changes (old behavior - when Claude doesn't commit)
          if [[ -n $(git status --porcelain) ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Found uncommitted changes"
          else
            # Check if Claude already committed and pushed (new behavior)
            # Fetch both main and the branch in a single operation to avoid stale data
            if ! git fetch origin main "${{ steps.branch.outputs.branch_name }}" --quiet 2>&1; then
              echo "‚ö†Ô∏è  Failed to fetch from remote - network error or branch doesn't exist"
              echo "Assuming no changes since fetch failed"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Validate branch exists on remote before checking commits
            if git ls-remote --exit-code --heads origin "${{ steps.branch.outputs.branch_name }}" > /dev/null 2>&1; then
              # Count commits with explicit error handling
              if ! COMMITS=$(git rev-list origin/main..origin/${{ steps.branch.outputs.branch_name }} --count 2>&1); then
                echo "‚ö†Ô∏è  Failed to count commits - assuming no changes"
                COMMITS="0"
              fi

              if [ "$COMMITS" -gt 0 ]; then
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "‚úÖ Found $COMMITS committed change(s) - Claude already pushed"
              else
                echo "has_changes=false" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è  No changes found"
              fi
            else
              # Branch doesn't exist on remote yet (Claude created locally but hasn't pushed)
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  Branch not pushed to remote yet"
            fi
          fi

      - name: Commit changes
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          # Only commit if there are uncommitted changes (Claude didn't commit)
          if [[ -n $(git status --porcelain) ]]; then
            git add .
            git commit -m "Claude: Automated changes for issue #${{ github.event.issue.number || github.event.pull_request.number }}

          Triggered by: ${{ github.event.comment.user.login || github.event.issue.user.login }}
          Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            echo "‚úÖ Committed changes"
          else
            echo "‚è≠Ô∏è  Skipping commit - Claude already committed"
          fi

      - name: Push branch
        if: steps.changes.outputs.has_changes == 'true'
        timeout-minutes: 5
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          # Ensure push_output.txt is cleaned up in all exit paths
          trap 'rm -f push_output.txt' EXIT

          # Only push if there are unpushed commits (Claude didn't push)
          # Note: There is a known TOCTOU (time-of-check-time-of-use) race condition here:
          # Another push could occur between the fetch and SHA comparison. This is acceptable
          # because the subsequent push will fail with a non-fast-forward error, which we handle
          # gracefully by exiting with code 0 to defer to the concurrent workflow.
          if ! git fetch origin "${{ steps.branch.outputs.branch_name }}" --quiet 2>&1; then
            echo "‚ö†Ô∏è  Failed to fetch branch from remote"
            echo "Network error or branch doesn't exist yet - will attempt push anyway"
          fi

          LOCAL_SHA=$(git rev-parse HEAD)

          # Get remote SHA with explicit error handling
          if ! REMOTE_SHA=$(git rev-parse origin/${{ steps.branch.outputs.branch_name }} 2>&1); then
            echo "‚ö†Ô∏è  Remote branch not found - will push as new branch"
            REMOTE_SHA=""
          fi

          if [ "$LOCAL_SHA" != "$REMOTE_SHA" ]; then
            # CRITICAL SECURITY: Mask token IMMEDIATELY before any use
            echo "::add-mask::${GH_TOKEN}"

            # Configure git credential helper for this single command
            # This avoids exposing the token in the remote URL or git config
            # Using GH_PAT (not GITHUB_TOKEN) to trigger workflow events
            if git -c credential.helper='!f() { echo "username=x-access-token"; echo "password=${GH_TOKEN}"; }; f' \
                push origin "${{ steps.branch.outputs.branch_name }}" 2>&1 | tee push_output.txt; then
              echo "‚úÖ Pushed changes"
            else
              # Check if push failed due to concurrent modification
              if grep -q "rejected\|non-fast-forward" push_output.txt; then
                echo "‚ö†Ô∏è  Push rejected - concurrent modification detected"
                echo "Another commit was pushed to the branch while this workflow was running."
                echo "This is a race condition - exiting gracefully to allow concurrent workflow to handle it."
                exit 0
              else
                echo "‚ùå Push failed with unexpected error:"
                cat push_output.txt
                exit 1
              fi
            fi
          else
            echo "‚è≠Ô∏è  Skipping push - Claude already pushed"
          fi

      - name: Re-request review and trigger re-review
        if: github.event_name == 'pull_request_review' && github.event.review.state == 'CHANGES_REQUESTED' && steps.changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          REVIEWER="${{ github.event.review.user.login }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"

          echo "üîÑ Re-requesting review from @$REVIEWER after addressing feedback..."

          # Re-request review from original reviewer
          gh pr edit "$PR_NUMBER" --add-reviewer "$REVIEWER" || {
            echo "‚ö†Ô∏è  Failed to re-request review (may already be requested)"
            echo "This is non-critical - continuing with workflow trigger"
          }

          echo "ü§ñ Triggering automated re-review..."

          # Trigger claude-review.yml via repository_dispatch
          # This bypasses the synchronize skip logic for faster feedback
          gh api repos/${{ github.repository }}/dispatches \
            -f event_type=re-review \
            -f client_payload[pr_number]="$PR_NUMBER" || {
            echo "‚ùå Failed to trigger re-review workflow"
            exit 1
          }

          echo "‚úÖ Review re-requested and re-review workflow triggered"

      - name: Check for unique commits
        if: steps.changes.outputs.has_changes == 'true'
        id: commit_check
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Count commits that are on this branch but not on main
          # Use origin/main..HEAD to compare against remote main and current HEAD
          # This works regardless of whether the branch is tracked remotely yet
          COMMITS=$(git rev-list origin/main..HEAD --count)
          echo "commit_count=$COMMITS" >> $GITHUB_OUTPUT

          if [ "$COMMITS" -eq 0 ]; then
            echo "‚ö†Ô∏è  No unique commits found - another workflow may have completed this task"
            echo "Branch has no commits that aren't already in main. This is likely a race condition."

            # Check if there's already a PR for this issue
            ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
            EXISTING_PR=$(gh pr list --search "in:title #${ISSUE_NUM}" --state all --json number,title --jq '.[0].number // empty')

            if [ -n "$EXISTING_PR" ]; then
              echo "‚úÖ PR #$EXISTING_PR already exists for this issue"
            fi

            exit 0
          fi

          echo "‚úÖ Found $COMMITS unique commit(s) to create PR"

      - name: Detect multi-phase issue
        if: steps.changes.outputs.has_changes == 'true' && steps.commit_check.outputs.commit_count > 0
        id: multi_phase
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"

          # Get issue body and title
          ISSUE_DATA=$(gh issue view $ISSUE_NUM --json body,title,labels)
          ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body // ""')
          ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r '.title // ""')

          # Check for multi-phase indicators
          IS_MULTI_PHASE=false

          # Pattern 1: Uncompleted checkboxes (task lists)
          UNCOMPLETED_TASKS=$(echo "$ISSUE_BODY" | grep -c '^\s*- \[ \]' || echo "0")
          if [ "$UNCOMPLETED_TASKS" -gt 0 ]; then
            echo "‚úì Found uncompleted task list items: $UNCOMPLETED_TASKS uncompleted"
            IS_MULTI_PHASE=true
          fi

          # Pattern 2: Phase/Step/Part mentions
          if echo "$ISSUE_BODY $ISSUE_TITLE" | grep -qiE '(phase|step|part) [0-9]+'; then
            echo "‚úì Found phase/step/part mentions in issue"
            IS_MULTI_PHASE=true
          fi

          # Pattern 3: Epic label
          if echo "$ISSUE_DATA" | jq -e '.labels[] | select(.name | test("epic|multi-phase"; "i"))' > /dev/null 2>&1; then
            echo "‚úì Found epic/multi-phase label"
            IS_MULTI_PHASE=true
          fi

          # Save result
          if [ "$IS_MULTI_PHASE" = true ]; then
            echo "is_multi_phase=true" >> $GITHUB_OUTPUT
            echo "üéØ Multi-phase issue detected - will use 'Part of #' instead of 'Closes #'"
          else
            echo "is_multi_phase=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Single-phase issue - will use 'Closes #'"
          fi

      - name: Create Pull Request
        if: steps.changes.outputs.has_changes == 'true' && steps.commit_check.outputs.commit_count > 0
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"

          # Final safety check: Verify commits still exist after push
          git fetch origin main
          FINAL_COMMITS=$(git rev-list origin/main..${{ steps.branch.outputs.branch_name }} --count)
          if [ "$FINAL_COMMITS" -eq 0 ]; then
            echo "‚ö†Ô∏è  No unique commits after push - branch may have been merged or reset"
            echo "Skipping PR creation to avoid 'No commits between branches' error"
            exit 0
          fi

          echo "‚úÖ Verified $FINAL_COMMITS commit(s) exist - proceeding with PR creation"

          # Check if a PR already exists for this branch
          EXISTING_PR=$(gh pr list --head "${{ steps.branch.outputs.branch_name }}" --json number --jq '.[0].number // empty')
          if [ -n "$EXISTING_PR" ]; then
            echo "‚úÖ PR #$EXISTING_PR already exists for branch ${{ steps.branch.outputs.branch_name }}"
            echo "Skipping PR creation to avoid duplicate"
            exit 0
          fi

          # Use appropriate closing keyword based on multi-phase detection
          if [ "${{ steps.multi_phase.outputs.is_multi_phase }}" = "true" ]; then
            CLOSING_KEYWORD="Part of #${ISSUE_NUM}"
            echo "üîÑ Using 'Part of #${ISSUE_NUM}' to avoid premature issue closure"
          else
            CLOSING_KEYWORD="Closes #${ISSUE_NUM}"
            echo "‚úÖ Using 'Closes #${ISSUE_NUM}' for single-phase issue"
          fi

          PR_TITLE="Claude: Changes for #${ISSUE_NUM}"
          PR_BODY="## Automated changes by Claude Code

          This PR was automatically created in response to [issue #${ISSUE_NUM}](${{ github.event.issue.html_url || github.event.pull_request.html_url }}).

          **Requested by:** @${{ github.event.comment.user.login || github.event.issue.user.login }}
          **Workflow run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ### Changes
          Claude has made the requested changes. Please review before merging.

          ### Working with this PR
          To have Claude handle merge conflicts or make additional changes:
          - Comment \`@claude\` with your request on this PR
          - Claude can run \`git merge\`, \`git pull\`, and \`gh pr\` commands
          - Claude will automatically commit and push changes

          $CLOSING_KEYWORD"

          # Get the requester (PR author) for assignment
          REQUESTER="${{ github.event.comment.user.login || github.event.issue.user.login || github.event.pull_request.user.login }}"

          gh pr create \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --base main \
            --head "${{ steps.branch.outputs.branch_name }}" \
            --assignee "$REQUESTER" \
            --label "automated,claude-code,üü† in-review"

      - name: Update issue label to done
        if: steps.changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
          # Remove in-progress label and add done label in a single API call
          # Note: Using '2>/dev/null || true' intentionally - label may not exist
          gh issue edit "$ISSUE_NUM" \
            --remove-label "üîµ in-progress" \
            --add-label "‚úÖ done" \
            2>/dev/null || true

      - name: Update progress comment
        if: always() && steps.progress_comment.outputs.result
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_pat.outputs.selected_pat || secrets.GITHUB_TOKEN }}
          script: |
            const status = '${{ job.status }}';
            const icons = {
              success: '‚úÖ',
              cancelled: 'üîÑ',
              failure: '‚ùå'
            };
            const messages = {
              success: 'Work completed',
              cancelled: 'Work cancelled',
              failure: 'Work failed'
            };

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ steps.progress_comment.outputs.result }},
              body: `## ${icons[status]} ${messages[status]}

            **Agent**: ${{ steps.select_pat.outputs.selected_username }}
            **Workflow**: [Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            });

      - name: Handle cancellation
        if: cancelled()
        env:
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üîÑ Workflow Cancelled for Issue #${ISSUE_NUM}"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo
          echo "This workflow was cancelled because a newer workflow started."
          echo "This is expected behavior due to concurrency controls."
          echo
          echo "The newer workflow will handle the request."
          echo "No action needed."
          echo

          # Remove in-progress label but don't add failed label
          # Note: Using '2>/dev/null || true' intentionally - label may not exist
          gh issue edit "$ISSUE_NUM" --remove-label "üîµ in-progress" 2>/dev/null || true

          # Post clarifying comment on PR/issue to explain the cancellation
          # Use --repo flag in case this runs before checkout
          # Note: Using '2>/dev/null || true' intentionally - comment may fail if permissions lacking
          gh issue comment "$ISSUE_NUM" --repo ${{ github.repository }} --body "üîÑ **Workflow Cancelled**

          This workflow run was cancelled because a newer @claude request was triggered. This is normal behavior to prevent conflicts.

          The newer workflow will complete the requested changes.

          Cancelled run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" 2>/dev/null || true

      - name: Handle failure
        if: failure()
        env:
          # Fallback to GITHUB_TOKEN if select_pat step hasn't run yet
          GH_TOKEN: ${{ steps.select_pat.outputs.selected_pat || secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üîç Analyzing Failure for Issue #${ISSUE_NUM}"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo

          # Check if this is a real failure or a race condition
          echo "Step 1: Checking for existing PRs..."
          EXISTING_PR=$(gh pr list --search "in:title #${ISSUE_NUM}" --state all --json number,state,url --jq '.[0] | select(.state == "OPEN" or .state == "MERGED") | "\(.number)|\(.state)|\(.url)"')

          if [ -n "$EXISTING_PR" ]; then
            IFS='|' read -r PR_NUM PR_STATE PR_URL <<< "$EXISTING_PR"
            echo "‚úÖ Found existing PR #${PR_NUM} (${PR_STATE})"
            echo "   URL: ${PR_URL}"
            echo
            echo "üéØ Conclusion: This workflow run was redundant"
            echo "   Reason: Another concurrent workflow already created a PR"
            echo "   Action: Not adding failed label - work is complete"
            exit 0
          fi

          echo "Step 2: Checking for other successful branches..."
          OTHER_BRANCHES=$(git branch -r | grep "claude/issue-${ISSUE_NUM}-" | wc -l | tr -d ' ')

          if [ "$OTHER_BRANCHES" -gt 1 ]; then
            echo "‚úÖ Found $OTHER_BRANCHES branch(es) for this issue"
            echo
            echo "üéØ Conclusion: Another workflow may have completed this task"
            echo "   Reason: Multiple branches exist, suggesting concurrent runs"
            echo "   Action: Not adding failed label - check branches manually if needed"
            exit 0
          fi

          echo "Step 3: No evidence of successful completion found"
          echo
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚ùå Genuine Failure Detected"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Issue #${ISSUE_NUM}: No PRs or successful branches found"
          echo "Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo
          echo "Next steps:"
          echo "  1. Review workflow logs for specific error"
          echo "  2. Check if this is a Claude issue or infrastructure issue"
          echo "  3. Re-trigger with @claude if appropriate"
          echo

          # This is a real failure - add the label
          if gh issue edit "$ISSUE_NUM" --add-label "‚ùå failed"; then
            echo "‚úì Added '‚ùå failed' label to issue #${ISSUE_NUM}"
          else
            echo "‚ö†Ô∏è  Warning: Failed to add label to issue #${ISSUE_NUM}"
          fi

      - name: Cleanup Neon Branch
        id: cleanup
        if: always() && steps.neon-branch.outputs.branch_id  # Cleanup if branch was created
        continue-on-error: true  # Non-blocking: report failure but don't fail workflow
        uses: neondatabase/delete-branch-action@v3
        timeout-minutes: 5  # Typical: <10s, allows time for retries
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch: claude/issue-${{ github.event.issue.number || github.event.pull_request.number }}-${{ github.run_id }}
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Report Cleanup Failure
        if: always() && steps.cleanup.outcome == 'failure'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
          BRANCH_ID="${{ steps.neon-branch.outputs.branch_id }}"

          echo "‚ö†Ô∏è Failed to cleanup Neon branch: $BRANCH_ID"
          echo "The branch may need to be manually deleted to avoid accumulation"

          # Post warning comment about orphaned branch
          gh issue comment "$ISSUE_NUM" --repo ${{ github.repository }} --body "## ‚ö†Ô∏è Neon Branch Cleanup Failed

          Failed to automatically delete the ephemeral Neon database branch.

          **Branch ID**: \`$BRANCH_ID\`
          **Project ID**: \`${{ vars.NEON_PROJECT_ID }}\`

          This branch may need to be manually deleted to prevent accumulation. You can delete it using:
          - Neon Console: https://console.neon.tech
          - Neon CLI: \`neonctl branches delete $BRANCH_ID --project-id ${{ vars.NEON_PROJECT_ID }}\`

          This is a non-critical issue and does not affect the workflow results.

          ---
          _Automated cleanup failure notification_" || echo "Failed to post cleanup warning comment"

